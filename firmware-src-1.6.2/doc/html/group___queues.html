<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>Make Controller Kit - Firmware API: Queues</title>
  <link href="mt_doxygen.css" rel="stylesheet" type="text/css" />
  <link href="../resources/mt_doxytabs.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div id="header">
    <a href="http://www.makingthings.com">
      <img src="../resources/logo.png" alt="MakingThings" border="0"/>
    </a>
    <form id='searchbox' method="get" action="http://www.google.com/search">
      <div align="right">
        <input type="text"   name="q" size="25" maxlength="255" value="" />
        <input type="submit" value="Search" />
        <input type="hidden" name="sitesearch" value="makingthings.com/ref/firmware/html" />
      </div>
    </form>
  </div>

<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Queues<br>
<small>
[<a class="el" href="group___r_t_o_s.html">RTOS</a>]</small>
</h1>Queues allow for thread-safe inter-process communication.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queues.html#gc2d1cdfeaaa00285b5c67260c0d2a64d">QueueCreate</a> (uint length, uint itemSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new queue.  <a href="#gc2d1cdfeaaa00285b5c67260c0d2a64d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queues.html#gcb0105420a21d83abeb9abc04f412e9f">QueueSendToFront</a> (void *queue, void *itemToQueue, int msToWait)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post an item onto the front of a queue.  <a href="#gcb0105420a21d83abeb9abc04f412e9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queues.html#g24a3155b7ac8bd256eeb82bcc4b6d9aa">QueueSendToBack</a> (void *queue, void *itemToQueue, int msToWait)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post an item onto the back of a queue.  <a href="#g24a3155b7ac8bd256eeb82bcc4b6d9aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queues.html#ge6957dcef9dfcf94627ddf6b56e46983">QueueReceive</a> (void *queue, void *buffer, int msToWait)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an item off of a queue.  <a href="#ge6957dcef9dfcf94627ddf6b56e46983"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queues.html#g900ddfe9c08c30101e5dce0eb8572ed3">QueueMessagesWaiting</a> (void *queue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of messages waiting in a queue.  <a href="#g900ddfe9c08c30101e5dce0eb8572ed3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queues.html#g732b8a550d25382ecbf8f28744a5199d">QueueDelete</a> (void *queue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a queue - freeing all the memory allocated for storing of items placed on the queue.  <a href="#g732b8a550d25382ecbf8f28744a5199d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queues.html#gbd4e727f53b330ab99f56db41459e5ad">QueueSendToFrontFromISR</a> (void *queue, void *itemToSend, int taskPreviouslyWoken)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post an item to the front of a queue from within an interrupt service routine.  <a href="#gbd4e727f53b330ab99f56db41459e5ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queues.html#gba2ceb616e0eac3cb7346ed0f76ecc23">QueueSendToBackFromISR</a> (void *queue, void *itemToSend, int taskPreviouslyWoken)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post an item to the back of a queue from within an interrupt service routine.  <a href="#gba2ceb616e0eac3cb7346ed0f76ecc23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___queues.html#g3d94a308309a75f2c3c9a6fd1bbfc712">QueueReceiveFromISR</a> (void *queue, void *buffer, long *taskWoken)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an item from a queue from within an interrupt service routine.  <a href="#g3d94a308309a75f2c3c9a6fd1bbfc712"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Queues allow for thread-safe inter-process communication. 
<p>
A queue is a list of items that can be passed from one task to another. Items are placed in a queue by copy - not by reference. It is therefore preferable, when queuing large items, to only queue a pointer to the item. Tasks can block on a queue to wait for either data to become available on the queue, or space to become available to write to the queue.<p>
More info at <a href="http://www.freertos.org">http://www.freertos.org</a> - some documentation here used from the FreeRTOS doc by Richard Barry. <hr><h2>Function Documentation</h2>
<a class="anchor" name="gc2d1cdfeaaa00285b5c67260c0d2a64d"></a><!-- doxytag: member="rtos.c::QueueCreate" ref="gc2d1cdfeaaa00285b5c67260c0d2a64d" args="(uint length, uint itemSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* QueueCreate           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>itemSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new queue. 
<p>
This allocates storage for the queue. It's usually a good idea to pass around pointers on queues as opposed to whole data structures, as that's quite resource intensive. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The maximum number of items that the queue can contain. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>itemSize</em>&nbsp;</td><td>The number of bytes each item in the queue will require. Items are queued by copy, not by reference, so this is the number of bytes that will be copied for each posted item. Each item on the queue must be the same size. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the queue on success, 0 if the queue couldn't be created.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>myData_
  {
    <span class="keywordtype">int</span> count;
    <span class="keywordtype">char</span> buffer[100];
  };

  <span class="comment">// create a queue that can hold 5 pointers to myData structures</span>
  <span class="keyword">struct </span>MyData_* myData;
  <span class="keywordtype">void</span>* myQueue = <a class="code" href="group___queues.html#gc2d1cdfeaaa00285b5c67260c0d2a64d" title="Create a new queue.">QueueCreate</a>( 5, <span class="keyword">sizeof</span>( myData* ) );
  <span class="keywordflow">if</span>( myQueue == 0 )
    <span class="comment">// then the queue can't be used.</span>
  <span class="keywordflow">else</span>
    <span class="comment">// continue processing...</span>
</pre></div> </dd></dl>

<p>Definition at line <a class="el" href="rtos_8c-source.html#l00569">569</a> of file <a class="el" href="rtos_8c-source.html">rtos.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g732b8a550d25382ecbf8f28744a5199d"></a><!-- doxytag: member="rtos.c::QueueDelete" ref="g732b8a550d25382ecbf8f28744a5199d" args="(void *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QueueDelete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>queue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a queue - freeing all the memory allocated for storing of items placed on the queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>The queue to delete.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">  <a class="code" href="group___queues.html#g732b8a550d25382ecbf8f28744a5199d" title="Delete a queue - freeing all the memory allocated for storing of items placed on...">QueueDelete</a>( myQueue );
</pre></div> </dd></dl>

<p>Definition at line <a class="el" href="rtos_8c-source.html#l00722">722</a> of file <a class="el" href="rtos_8c-source.html">rtos.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g900ddfe9c08c30101e5dce0eb8572ed3"></a><!-- doxytag: member="rtos.c::QueueMessagesWaiting" ref="g900ddfe9c08c30101e5dce0eb8572ed3" args="(void *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QueueMessagesWaiting           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>queue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of messages waiting in a queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>The queue to look at. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of messages waiting.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> msgs = <a class="code" href="group___queues.html#g900ddfe9c08c30101e5dce0eb8572ed3" title="Return the number of messages waiting in a queue.">QueueMessagesWaiting</a>( myQueue );
</pre></div> </dd></dl>

<p>Definition at line <a class="el" href="rtos_8c-source.html#l00708">708</a> of file <a class="el" href="rtos_8c-source.html">rtos.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge6957dcef9dfcf94627ddf6b56e46983"></a><!-- doxytag: member="rtos.c::QueueReceive" ref="ge6957dcef9dfcf94627ddf6b56e46983" args="(void *queue, void *buffer, int msToWait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QueueReceive           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msToWait</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read an item off of a queue. 
<p>
The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created. The item will be removed from the queue once it is read.<p>
This function must not be used in an interrupt service routine. See <a class="el" href="group___queues.html#g3d94a308309a75f2c3c9a6fd1bbfc712" title="Receive an item from a queue from within an interrupt service routine.">QueueReceiveFromISR( )</a> for an alternative that can. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>The queue to receive from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to the buffer the item will be read into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msToWait</em>&nbsp;</td><td>The maximum number of milliseconds the task should block waiting for an item to show up on the queue, should it be empty. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyData_
  {
    <span class="keywordtype">int</span> count;
    <span class="keywordtype">char</span> buffer[100];
  };
  
  <span class="keywordtype">void</span>* myQueue;
  
  <span class="keywordtype">void</span> SomeTask( <span class="keywordtype">void</span>* p )
  {
    <span class="comment">// create a queue that can hold 5 pointers to myData structures</span>
    myQueue = <a class="code" href="group___queues.html#gc2d1cdfeaaa00285b5c67260c0d2a64d" title="Create a new queue.">QueueCreate</a>( 5, <span class="keyword">sizeof</span>( myData* ) );
    <span class="keyword">struct </span>MyData_ myData; <span class="comment">// the data we'll be sending</span>
    myData.count = 12;
    myData.buffer = <span class="stringliteral">"ABCDEF"</span>;
    
    <a class="code" href="group___queues.html#gcb0105420a21d83abeb9abc04f412e9f" title="Post an item onto the front of a queue.">QueueSendToFront</a>( myQueue, &amp;myData, 0 );
  }
  
  <span class="keywordtype">void</span> AnotherTask( <span class="keywordtype">void</span>* p )
  {
    <span class="keywordtype">int</span> dataSize = <span class="keyword">sizeof</span>( <span class="keyword">struct </span>MyData_ );
    <span class="keyword">struct </span>MyData_* rxData; <span class="comment">// a pointer to some data</span>
    <span class="keywordflow">if</span>( myQueue )
    {
      <span class="keywordflow">if</span>( <a class="code" href="group___queues.html#ge6957dcef9dfcf94627ddf6b56e46983" title="Read an item off of a queue.">QueueReceive</a>( myQueue, rxData, 100 ) ) <span class="comment">// wait up to 100 milliseconds for data</span>
      {
        <span class="comment">// now rxData points to the data posted in SomeTask</span>
      }
    }
  }
</pre></div> </dd></dl>

<p>Definition at line <a class="el" href="rtos_8c-source.html#l00692">692</a> of file <a class="el" href="rtos_8c-source.html">rtos.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g3d94a308309a75f2c3c9a6fd1bbfc712"></a><!-- doxytag: member="rtos.c::QueueReceiveFromISR" ref="g3d94a308309a75f2c3c9a6fd1bbfc712" args="(void *queue, void *buffer, long *taskWoken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QueueReceiveFromISR           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>taskWoken</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive an item from a queue from within an interrupt service routine. 
<p>
You'll need to have enough storage for the queue to copy the item into. Receiving from a queue takes the item off the queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>The queue to receive from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to the buffer into which the received item will be copied - ensure that there's enough room. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>taskWoken</em>&nbsp;</td><td>A task may be blocked waiting for an item to be read from the queue, freeing up space. If QueueReceiveFromISR causes such a task to unblock *taskWoken will get set to 1, otherwise *taskWoken will remain unchanged. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if an item was successfully received from the queue, otherwise 0. switch may be required following the ISR.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">  
  <span class="keywordtype">int</span> taskWokenByReceive = 0; <span class="comment">// be sure to initialize to 0</span>
  <span class="keywordtype">void</span>* myQueue = <a class="code" href="group___queues.html#gc2d1cdfeaaa00285b5c67260c0d2a64d" title="Create a new queue.">QueueCreate</a>( 5, <span class="keyword">sizeof</span>( <span class="keywordtype">char</span> ) );
  <span class="keywordflow">if</span>( myQueue == 0 )
    <span class="comment">// queue couldn't be created...</span>
  
  <span class="keywordtype">char</span> data;

  <span class="keywordflow">while</span>( <a class="code" href="group___queues.html#g3d94a308309a75f2c3c9a6fd1bbfc712" title="Receive an item from a queue from within an interrupt service routine.">QueueReceiveFromISR</a>( myQueue, (<span class="keywordtype">void</span>*)&amp;data, taskWokenByReceive ) )
  {
    <span class="comment">// process new items from queue here</span>
    
    <span class="comment">// If removing an item from the queue woke the task that was </span>
    <span class="comment">// posting onto the queue, taskWokenByReceive will have been set to</span>
    <span class="comment">// 1.  No matter how many times this loop iterates only one</span>
    <span class="comment">// task will be woken.</span>
  }
  <span class="keywordflow">if</span>( taskWokenByReceive )
  {
      <span class="comment">// We should switch context so the ISR returns to a different task.    </span>
      taskYIELD ();
  }
</pre></div> </dd></dl>

<p>Definition at line <a class="el" href="rtos_8c-source.html#l00845">845</a> of file <a class="el" href="rtos_8c-source.html">rtos.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g24a3155b7ac8bd256eeb82bcc4b6d9aa"></a><!-- doxytag: member="rtos.c::QueueSendToBack" ref="g24a3155b7ac8bd256eeb82bcc4b6d9aa" args="(void *queue, void *itemToQueue, int msToWait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QueueSendToBack           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>itemToQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msToWait</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Post an item onto the back of a queue. 
<p>
The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>The queue to send to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>itemToQueue</em>&nbsp;</td><td>A pointer to the item to send on the queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msToWait</em>&nbsp;</td><td>The maximum number of milliseconds the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyData_
  {
    <span class="keywordtype">int</span> count;
    <span class="keywordtype">char</span> buffer[100];
  };

  <span class="comment">// create a queue that can hold 5 pointers to myData structures</span>
  <span class="keyword">struct </span>MyData_* myData;
  <span class="keywordtype">void</span>* myQueue = <a class="code" href="group___queues.html#gc2d1cdfeaaa00285b5c67260c0d2a64d" title="Create a new queue.">QueueCreate</a>( 5, <span class="keyword">sizeof</span>( myData* ) );
  <span class="keywordflow">if</span>( myQueue )
  {
    <span class="keywordflow">if</span>( <a class="code" href="group___queues.html#g24a3155b7ac8bd256eeb82bcc4b6d9aa" title="Post an item onto the back of a queue.">QueueSendToBack</a>( myQueue, (<span class="keywordtype">void</span>*)&amp;myData, 10 ) ) <span class="comment">// wait 10 ms to send if queue is full</span>
      <span class="comment">// then we're all set</span>
    <span class="keywordflow">else</span>
      <span class="comment">// deal with an unsuccessful send</span>
  }
</pre></div> </dd></dl>

<p>Definition at line <a class="el" href="rtos_8c-source.html#l00639">639</a> of file <a class="el" href="rtos_8c-source.html">rtos.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gba2ceb616e0eac3cb7346ed0f76ecc23"></a><!-- doxytag: member="rtos.c::QueueSendToBackFromISR" ref="gba2ceb616e0eac3cb7346ed0f76ecc23" args="(void *queue, void *itemToSend, int taskPreviouslyWoken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QueueSendToBackFromISR           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>itemToSend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>taskPreviouslyWoken</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Post an item to the back of a queue from within an interrupt service routine. 
<p>
Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>The queue to send to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>itemToSend</em>&nbsp;</td><td>A pointer to the item to send on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from itemToSend into the queue storage area. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>taskPreviouslyWoken</em>&nbsp;</td><td>This is included so an ISR can post onto the same queue multiple times from a single interrupt. The first call should always pass in 0. Subsequent calls should pass in the value returned from the previous call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if a task was woken by posting onto the queue. This is used by the ISR to determine if a context switch may be required following the ISR.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyData_
  {
    <span class="keywordtype">int</span> count;
    <span class="keywordtype">char</span> buffer[100];
  };
  
  <span class="keywordtype">int</span> taskWokenByPost = 0; <span class="comment">// be sure to initialize to 0</span>

  <span class="comment">// create a queue that can hold 5 pointers to myData structures</span>
  <span class="keyword">struct </span>MyData_ myData;
  <span class="keywordtype">void</span>* myQueue = <a class="code" href="group___queues.html#gc2d1cdfeaaa00285b5c67260c0d2a64d" title="Create a new queue.">QueueCreate</a>( 5, <span class="keyword">sizeof</span>( myData* ) );
  <span class="keywordflow">if</span>( myQueue )
  {
    taskWokenByPost = <a class="code" href="group___queues.html#gba2ceb616e0eac3cb7346ed0f76ecc23" title="Post an item to the back of a queue from within an interrupt service routine.">QueueSendToBackFromISR</a>( myQueue, (<span class="keywordtype">void</span>*)&amp;myData, taskWokenByPost )
    if( taskWokenByPost )
    {
        <span class="comment">// We should switch context so the ISR returns to a different task.    </span>
        portYIELD_FROM_ISR( );
    }
  }
</pre></div> </dd></dl>

<p>Definition at line <a class="el" href="rtos_8c-source.html#l00804">804</a> of file <a class="el" href="rtos_8c-source.html">rtos.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gcb0105420a21d83abeb9abc04f412e9f"></a><!-- doxytag: member="rtos.c::QueueSendToFront" ref="gcb0105420a21d83abeb9abc04f412e9f" args="(void *queue, void *itemToQueue, int msToWait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QueueSendToFront           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>itemToQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msToWait</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Post an item onto the front of a queue. 
<p>
The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>The queue to send to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>itemToQueue</em>&nbsp;</td><td>A pointer to the item to send on the queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msToWait</em>&nbsp;</td><td>The maximum number of milliseconds the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyData_
  {
    <span class="keywordtype">int</span> count;
    <span class="keywordtype">char</span> buffer[100];
  };

  <span class="comment">// create a queue that can hold 5 pointers to myData structures</span>
  <span class="keyword">struct </span>MyData_* myData;
  <span class="keywordtype">void</span>* myQueue = <a class="code" href="group___queues.html#gc2d1cdfeaaa00285b5c67260c0d2a64d" title="Create a new queue.">QueueCreate</a>( 5, <span class="keyword">sizeof</span>( myData* ) );
  <span class="keywordflow">if</span>( myQueue )
  {
    <span class="keywordflow">if</span>( <a class="code" href="group___queues.html#gcb0105420a21d83abeb9abc04f412e9f" title="Post an item onto the front of a queue.">QueueSendToFront</a>( myQueue, (<span class="keywordtype">void</span>*)&amp;myData, 10 ) ) <span class="comment">// wait 10 ms to send if queue is full</span>
      <span class="comment">// then we're all set</span>
    <span class="keywordflow">else</span>
      <span class="comment">// deal with an unsuccessful send</span>
  }
</pre></div> </dd></dl>

<p>Definition at line <a class="el" href="rtos_8c-source.html#l00604">604</a> of file <a class="el" href="rtos_8c-source.html">rtos.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gbd4e727f53b330ab99f56db41459e5ad"></a><!-- doxytag: member="rtos.c::QueueSendToFrontFromISR" ref="gbd4e727f53b330ab99f56db41459e5ad" args="(void *queue, void *itemToSend, int taskPreviouslyWoken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QueueSendToFrontFromISR           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>itemToSend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>taskPreviouslyWoken</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Post an item to the front of a queue from within an interrupt service routine. 
<p>
Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>The queue to send to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>itemToSend</em>&nbsp;</td><td>A pointer to the item to send on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from itemToSend into the queue storage area. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>taskPreviouslyWoken</em>&nbsp;</td><td>This is included so an ISR can post onto the same queue multiple times from a single interrupt. The first call should always pass in 0. Subsequent calls should pass in the value returned from the previous call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if a task was woken by posting onto the queue. This is used by the ISR to determine if a context switch may be required following the ISR.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyData_
  {
    <span class="keywordtype">int</span> count;
    <span class="keywordtype">char</span> buffer[100];
  };
  
  <span class="keywordtype">int</span> taskWokenByPost = 0; <span class="comment">// be sure to initialize to 0</span>

  <span class="comment">// create a queue that can hold 5 pointers to myData structures</span>
  <span class="keyword">struct </span>MyData_ myData;
  <span class="keywordtype">void</span>* myQueue = <a class="code" href="group___queues.html#gc2d1cdfeaaa00285b5c67260c0d2a64d" title="Create a new queue.">QueueCreate</a>( 5, <span class="keyword">sizeof</span>( myData* ) );
  <span class="keywordflow">if</span>( myQueue )
  {
    taskWokenByPost = <a class="code" href="group___queues.html#gbd4e727f53b330ab99f56db41459e5ad" title="Post an item to the front of a queue from within an interrupt service routine.">QueueSendToFrontFromISR</a>( myQueue, (<span class="keywordtype">void</span>*)&amp;myData, taskWokenByPost )
    if( taskWokenByPost )
    {
        <span class="comment">// We should switch context so the ISR returns to a different task.    </span>
        portYIELD_FROM_ISR( );
    }
  }
</pre></div> </dd></dl>

<p>Definition at line <a class="el" href="rtos_8c-source.html#l00763">763</a> of file <a class="el" href="rtos_8c-source.html">rtos.c</a>.</p>

</div>
</div><p>
</div>

<hr size="1">
<div>
  <p id="footer">The Make Controller Kit is an open source project maintained by <a href="http://www.makingthings.com">MakingThings</a>.<br />
    MakingThings code is released under the <a href="http://www.apache.org/licenses/LICENSE-2.0.html" target="_blank">Apache 2.0 license</a>.<br />
    Bug tracker, development wiki and status can be found at <a href="http://dev.makingthings.com">http://dev.makingthings.com</a>.<br />
    This document was last updated on 18 May 2009.
  </p>
</div>
<!-- Google Analytics Code -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
_uacct = "UA-769030-1";
urchinTracker();
</script>
</body>
</html>
