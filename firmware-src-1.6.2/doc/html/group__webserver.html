<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>Make Controller Kit - Firmware API: Web Server</title>
  <link href="mt_doxygen.css" rel="stylesheet" type="text/css" />
  <link href="../resources/mt_doxytabs.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div id="header">
    <a href="http://www.makingthings.com">
      <img src="../resources/logo.png" alt="MakingThings" border="0"/>
    </a>
    <form id='searchbox' method="get" action="http://www.google.com/search">
      <div align="right">
        <input type="text"   name="q" size="25" maxlength="255" value="" />
        <input type="submit" value="Search" />
        <input type="hidden" name="sitesearch" value="makingthings.com/ref/firmware/html" />
      </div>
    </form>
  </div>

<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Web Server<br>
<small>
[<a class="el" href="group___libraries.html">Libraries</a>]</small>
</h1>A simple Web Server.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_html_form_element.html">HtmlFormElement</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure that represents a key-value pair in an HTML form.  <a href="struct_html_form_element.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_html_form.html">HtmlForm</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure that represents a collection of <a class="el" href="struct_html_form_element.html" title="A structure that represents a key-value pair in an HTML form.">HtmlFormElement</a> structures.  <a href="struct_html_form.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#g5a95d049647db95b76a70bc5f722719c">WebServer_SetActive</a> (int active)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the WebServer up, listening on port 80.  <a href="#g5a95d049647db95b76a70bc5f722719c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#g3c8767183fe744b19e9fb799fe1b0e27">WebServer_GetActive</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the active state of the WebServer subsystem.  <a href="#g3c8767183fe744b19e9fb799fe1b0e27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#g8d09559930507b44a8b6ba6888bcd8e0">WebServer_SetListenPort</a> (int port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the port that the webserver should listen on for new connections.  <a href="#g8d09559930507b44a8b6ba6888bcd8e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#g920af9c0e4153c414d94417d0ec2c263">WebServer_GetListenPort</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the port that the webserver is currently listening on.  <a href="#g920af9c0e4153c414d94417d0ec2c263"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#g617645f84a704ca27ed9650270ee2d26">WebServer_Route</a> (char *address, int(*handler)(char *requestType, char *address, char *requestBuffer, int requestMaxSize, void *socket, char *buffer, int len))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a route handler to the WebServer.  <a href="#g617645f84a704ca27ed9650270ee2d26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#ge56f4878fa8d9edea8144a125e331878">WebServer_WriteResponseOkHTML</a> (void *socket)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the HTTP OK message and sets the content type to HTML.  <a href="#ge56f4878fa8d9edea8144a125e331878"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#gf2e44af2fb70c641c47fc8954fd09067">WebServer_WriteResponseOkPlain</a> (void *socket)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the HTTP OK message and sets the content type to plain text.  <a href="#gf2e44af2fb70c641c47fc8954fd09067"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#g161fe09ada669a6f0a27f3e0dd6a0b0d">WebServer_WriteHeader</a> (int includeCSS, void *socket, char *buffer, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the HTML header.  <a href="#g161fe09ada669a6f0a27f3e0dd6a0b0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#g33a47f02bdd0f2d8fd662648c4c0cad4">WebServer_WriteBodyStart</a> (char *reloadAddress, void *socket, char *buffer, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the start of the BODY tag.  <a href="#g33a47f02bdd0f2d8fd662648c4c0cad4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#ge44633b0de4b28f0883744654f965e6d">WebServer_WriteBodyEnd</a> (void *socket)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the end of the Body tag - and the final end of HTML tag.  <a href="#ge44633b0de4b28f0883744654f965e6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#g76ac59af54bd0b41f903deb764595369">WebServer_GetPostData</a> (void *socket, char *requestBuffer, int maxSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the data of an incoming HTTP POST request to the given buffer.  <a href="#g76ac59af54bd0b41f903deb764595369"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__webserver.html#gadbe053e9daaebac415490ff62bbf227">WebServer_ParseFormElements</a> (char *request, <a class="el" href="struct_html_form.html">HtmlForm</a> *form)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract the elements of an HTML form into key/value pairs.  <a href="#gadbe053e9daaebac415490ff62bbf227"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A simple Web Server. 
<p>
This Web Server implementation is based on the <a class="el" href="group___sockets.html#g19a37ffe799e0d2de090a24a03e38cb7">ServerSocket</a> and <a class="el" href="group___sockets.html#g7e4b76e6d4a93aa7c281e5cbba6cc584">Socket</a> functions defined in <a class="el" href="group___sockets.html">Sockets</a>. When started, a ServerSocket is opened and set to listen on port 80.<p>
When the server receives a request, it checks the incoming address against a list of handlers. If the request address matches, the handler is invoked and checking stops. Users can add their own handlers to return custom information - see <a class="el" href="group__webserver.html#g617645f84a704ca27ed9650270ee2d26" title="Adds a route handler to the WebServer.">WebServer_Route()</a>. Most of the rest of the WebServer system provides helpful functions for generating and parsing HTML.<p>
There is a single default/test handler that will handle any requests that are not otherwise handled. This is about the simplest demo possible of how to write a handler - it simply prints out some text and a count of how pages it has served. There are more handler examples further down this page, and in the mcbuilder examples. Take a look at TestHandler() in <a class="el" href="webserver_8c.html" title="Functions for implementing a WebServer on the Make Controller Board.">webserver.c</a> to see its source.<p>
To access the web server type the IP address of your board into a web browser, optionally followed by the address of any handlers you've registered, ie <b>192.168.1.200/myhandler</b>. <hr><h2>Function Documentation</h2>
<a class="anchor" name="g3c8767183fe744b19e9fb799fe1b0e27"></a><!-- doxytag: member="webserver.c::WebServer_GetActive" ref="g3c8767183fe744b19e9fb799fe1b0e27" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_GetActive           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the active state of the WebServer subsystem. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>State - 1/non-zero (on) or 0 (off). </dd></dl>

<p>Definition at line <a class="el" href="webserver_8c-source.html#l00170">170</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g920af9c0e4153c414d94417d0ec2c263"></a><!-- doxytag: member="webserver.c::WebServer_GetListenPort" ref="g920af9c0e4153c414d94417d0ec2c263" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_GetListenPort           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the port that the webserver is currently listening on. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The port number.</dd></dl>
<b>Example</b> <div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> currentPort = <a class="code" href="group__webserver.html#g920af9c0e4153c414d94417d0ec2c263" title="Get the port that the webserver is currently listening on.">WebServer_GetListenPort</a>( );
</pre></div> 
<p>Definition at line <a class="el" href="webserver_8c-source.html#l00204">204</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g76ac59af54bd0b41f903deb764595369"></a><!-- doxytag: member="webserver.c::WebServer_GetPostData" ref="g76ac59af54bd0b41f903deb764595369" args="(void *socket, char *requestBuffer, int maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WebServer_GetPostData           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>requestBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the data of an incoming HTTP POST request to the given buffer. 
<p>
This is designed to be used from within a custom handler. An incoming HTTP request will have some number of lines of header information, and this function will read through them until getting to the body of the message. It will then store the contents of the body in the given buffer, null-terminating the end of the data.<p>
It's usually convenient to set the POST data in the requestBuffer since it's already allocated.<p>
<b>Example</b> <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> MyRequestHandler( <span class="keywordtype">char</span>* requestType, <span class="keywordtype">char</span>* address, <span class="keywordtype">char</span>* requestBuffer, 
                      <span class="keywordtype">int</span> requestMaxSize, <span class="keywordtype">void</span>* socket, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">int</span> len )
{
  <span class="comment">// ... other setup here ...</span>

  <span class="keywordflow">if</span> ( strncmp( requestType, <span class="stringliteral">"POST"</span>, 4 ) == 0 ) <span class="comment">// if the request is indeed a POST</span>
  {
    <span class="keywordflow">if</span>( <a class="code" href="group__webserver.html#g76ac59af54bd0b41f903deb764595369" title="Set the data of an incoming HTTP POST request to the given buffer.">WebServer_GetPostData</a>( socket, requestBuffer, requestMaxSize ) ) <span class="comment">// set the POST data in the requestBuffer</span>
    {
      <span class="comment">// process the data in any way you like.</span>
      <span class="comment">// here, we're expecting a form and we want to grab the info out of it</span>
      formElements = <a class="code" href="group__webserver.html#gadbe053e9daaebac415490ff62bbf227" title="Extract the elements of an HTML form into key/value pairs.">WebServer_ParseFormElements</a>( requestBuffer, &amp;form );
    }
  }

  <span class="comment">// ... write out the response here ...</span>
}
</pre></div> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>The socket from the incoming request </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>requestBuffer</em>&nbsp;</td><td>A pointer to the buffer to store the data in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSize</em>&nbsp;</td><td>The maximum amount of data to be placed in the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure </dd></dl>

<p>Definition at line <a class="el" href="webserver_8c-source.html#l00496">496</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gadbe053e9daaebac415490ff62bbf227"></a><!-- doxytag: member="webserver.c::WebServer_ParseFormElements" ref="gadbe053e9daaebac415490ff62bbf227" args="(char *request, HtmlForm *form)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_ParseFormElements           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_html_form.html">HtmlForm</a> *&nbsp;</td>
          <td class="paramname"> <em>form</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract the elements of an HTML form into key/value pairs. 
<p>
This is designed to be used from within a custom handler. HTML forms can be sent via either the HTTP GET or POST methods. The <b>request</b> parameter must be set to the start of the form data, which is located in a different place for each method. In the <b>GET</b> case, we need to check if there are any form elements, as indicated by a <b></b>? after the URL address. In the <b>POST</b> case, we can use <a class="el" href="group__webserver.html#g76ac59af54bd0b41f903deb764595369" title="Set the data of an incoming HTTP POST request to the given buffer.">WebServer_GetPostData()</a> to find the beginning of the POST data for us.<p>
Note that the <a class="el" href="struct_html_form.html" title="A structure that represents a collection of HtmlFormElement structures.">HtmlForm</a> structure will simply point to the elements in the request buffer, so as soon as the buffer is deleted or out of scope, the form data is no longer valid.<p>
<b>Example</b> <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> MyRequestHandler( <span class="keywordtype">char</span>* requestType, <span class="keywordtype">char</span>* address, <span class="keywordtype">char</span>* requestBuffer, 
                      <span class="keywordtype">int</span> requestMaxSize, <span class="keywordtype">void</span>* socket, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">int</span> len )
{
  <span class="comment">// ... other setup here ...</span>
  
  <span class="keywordtype">int</span> formElements = 0;
  <a class="code" href="struct_html_form.html" title="A structure that represents a collection of HtmlFormElement structures.">HtmlForm</a> form;
  form.<a class="code" href="struct_html_form.html#ea7470fe5e3bd89b82778558eb1d40d9" title="The number of form elements contained in this form.">count</a> = 0;
  
  <span class="comment">// determine the kind of request - GET or POST</span>
  <span class="keywordflow">if</span> ( strncmp( requestType, <span class="stringliteral">"GET"</span>, 3 ) == 0 )
  {
    <span class="keywordtype">char</span> *p = strchr( requestBuffer, <span class="charliteral">'?'</span> ); <span class="comment">// if GET, see if there's a ?</span>
    <span class="keywordflow">if</span>( p != NULL ) <span class="comment">// if we didn't find a ?, there were no form elements</span>
      formElements = <a class="code" href="group__webserver.html#gadbe053e9daaebac415490ff62bbf227" title="Extract the elements of an HTML form into key/value pairs.">WebServer_ParseFormElements</a>( p+1, &amp;form );
    <span class="comment">// we have to send "p + 1" since the form data starts right after the ?</span>
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( strncmp( requestType, <span class="stringliteral">"POST"</span>, 4 ) == 0 )
  {
    <span class="comment">// make sure we're pointing at the POST data and if it looks good, process it</span>
    <span class="keywordflow">if</span>( <a class="code" href="group__webserver.html#g76ac59af54bd0b41f903deb764595369" title="Set the data of an incoming HTTP POST request to the given buffer.">WebServer_GetPostData</a>( socket, requestBuffer, requestMaxSize ) )
      formElements = <a class="code" href="group__webserver.html#gadbe053e9daaebac415490ff62bbf227" title="Extract the elements of an HTML form into key/value pairs.">WebServer_ParseFormElements</a>( requestBuffer, &amp;form );
  }

  <span class="comment">// ... write out the response here ...</span>
}
</pre></div> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>request</em>&nbsp;</td><td>A pointer to the form data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>form</em>&nbsp;</td><td>The <a class="el" href="struct_html_form.html" title="A structure that represents a collection of HtmlFormElement structures.">HtmlForm</a> structure to populate with elements </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of form elements found </dd></dl>

<p>Definition at line <a class="el" href="webserver_8c-source.html#l00582">582</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g617645f84a704ca27ed9650270ee2d26"></a><!-- doxytag: member="webserver.c::WebServer_Route" ref="g617645f84a704ca27ed9650270ee2d26" args="(char *address, int(*handler)(char *requestType, char *address, char *requestBuffer, int requestMaxSize, void *socket, char *buffer, int len))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_Route           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(char *requestType, char *address, char *requestBuffer, int requestMaxSize, void *socket, char *buffer, int len)&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a route handler to the WebServer. 
<p>
This function binds an address fragment (e.g. "/", "/adcs", etc.) to a handler that will be called when the address matches. Matching ignores characters in the incoming address that are beyond the end of the address specified to this function. The first function to match the address will receive all the traffic and no more handlers will be checked. Thus if a handler is set up to match "/images" it will match "/images" and "/images/logo.png" and so on. Also if there is a subseqent handler set to match "/images/diagram" it will never be called since the prior handler will match the entire "/images" space. You can register your handlers prior to firing up the webserver system.<p>
The handler will be called with the request type specified (usually "GET" or "POST"), the incoming address ( "/device/0", "/images/logo.png", etc.) A buffer (and max length) is passed in that can be used to receive the rest of the message if necessary. Then there will be the socket which will take the response and a helpful large buffer or specified length which can be used to build strings.<p>
At the time the handler is called, only the first line of the request has been read. It is used to determine the request type and the address requested. If you need to process the request further its contents may be read into a buffer (the request buffer passed in is good once the request type address have been used since they're in there initially). The <a class="el" href="group___sockets.html#gabf4d267c62d67bd596a22daea799662" title="Read a line from a TCP socket terminated by CR LF (0x0D 0x0A).">SocketReadLine( )</a> function is convenient to read a line of the request at a time.<p>
The handler itself must first write the response using one of <a class="el" href="group__webserver.html#ge56f4878fa8d9edea8144a125e331878" title="Writes the HTTP OK message and sets the content type to HTML.">WebServer_WriteResponseOkHTML()</a> for sending HTML or <a class="el" href="group__webserver.html#gf2e44af2fb70c641c47fc8954fd09067" title="Writes the HTTP OK message and sets the content type to plain text.">WebServer_WriteResponseOkPlain()</a> for returning plain text. These send the appropriate HTTP header (for example "HTTP/1.0 200 OK\r\nContent-type:text/html\r\n\r\n"). All responses may be simply written to the Socket, but several helpers are provided to assist in the construction of simple web pages (for example <a class="el" href="group__webserver.html#g161fe09ada669a6f0a27f3e0dd6a0b0d" title="Writes the HTML header.">WebServer_WriteHeader()</a>, <a class="el" href="group__webserver.html#g33a47f02bdd0f2d8fd662648c4c0cad4" title="Writes the start of the BODY tag.">WebServer_WriteBodyStart()</a>, etc.).<p>
The handler should return non-zero if it handled the response appropriately or 0 if not, in which case the webserver will check for matches with other handlers that can handle it. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>An string specify the addresses to match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>pointer to a handler function that will be called when the address is matched. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>CONTROLLER_OK (=0) on success or the appropriate error if not</dd></dl>
Here is an example of how to register a handler: <div class="fragment"><pre class="fragment"><span class="comment">// now requests at MyBoardsIPAddress/my/handler will be handled by MyHandler</span>
<a class="code" href="group__webserver.html#g617645f84a704ca27ed9650270ee2d26" title="Adds a route handler to the WebServer.">WebServer_Route</a>( <span class="stringliteral">"/my/handler"</span>, MyHandler );
</pre></div><p>
And here is an example handler, printing out some simple info in response to any request. <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> MyHandler( <span class="keywordtype">char</span>* requestType, <span class="keywordtype">char</span>* address, <span class="keywordtype">char</span>* requestBuffer, <span class="keywordtype">int</span> requestMaxSize, 
                 <span class="keywordtype">void</span>* socket, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">int</span> len )
{
  (void)requestType;
  (void)address;
  <a class="code" href="group__webserver.html#ge56f4878fa8d9edea8144a125e331878" title="Writes the HTTP OK message and sets the content type to HTML.">WebServer_WriteResponseOkHTML</a>( socket );
  <a class="code" href="group__webserver.html#g161fe09ada669a6f0a27f3e0dd6a0b0d" title="Writes the HTML header.">WebServer_WriteHeader</a>( <span class="keyword">true</span>, socket, buffer, len );
  <a class="code" href="group__webserver.html#g33a47f02bdd0f2d8fd662648c4c0cad4" title="Writes the start of the BODY tag.">WebServer_WriteBodyStart</a>( address, socket, buffer, len );
  snprintf( buffer, len, <span class="stringliteral">"&lt;H1&gt;TEST&lt;/H1&gt;%d hits"</span>, WebServer-&gt;hits );
  <a class="code" href="group___sockets.html#g1031bc0757e65ea265deb5dc3ded3029" title="Write to a TCP socket.">SocketWrite</a>( socket, buffer, strlen( buffer ) );
  <a class="code" href="group__webserver.html#ge44633b0de4b28f0883744654f965e6d" title="Writes the end of the Body tag - and the final end of HTML tag.">WebServer_WriteBodyEnd</a>( socket );
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div> 
<p>Definition at line <a class="el" href="webserver_8c-source.html#l00269">269</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5a95d049647db95b76a70bc5f722719c"></a><!-- doxytag: member="webserver.c::WebServer_SetActive" ref="g5a95d049647db95b76a70bc5f722719c" args="(int active)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_SetActive           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>active</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the WebServer up, listening on port 80. 
<p>
See <a class="el" href="group__webserver.html#g617645f84a704ca27ed9650270ee2d26" title="Adds a route handler to the WebServer.">WebServer_Route()</a> for info on how to register handlers for certain requests. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>active</em>&nbsp;</td><td>An integer specifying the active state - 1 (on) or 0 (off). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>CONTROLLER_OK (0) on success or the appropriate error if not</dd></dl>
<b>Example</b> <div class="fragment"><pre class="fragment">  <span class="comment">// fire up the webserver</span>
  <a class="code" href="group__webserver.html#g5a95d049647db95b76a70bc5f722719c" title="Start the WebServer up, listening on port 80.">WebServer_SetActive</a>(<span class="keyword">true</span>);
</pre></div> 
<p>Definition at line <a class="el" href="webserver_8c-source.html#l00122">122</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g8d09559930507b44a8b6ba6888bcd8e0"></a><!-- doxytag: member="webserver.c::WebServer_SetListenPort" ref="g8d09559930507b44a8b6ba6888bcd8e0" args="(int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_SetListenPort           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the port that the webserver should listen on for new connections. 
<p>
Note that this does not immediately take effect - because the webserver (if it's open) is already listening on a port, it will only take effect after it serves one last request on that port. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The new port to listen on. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success.</dd></dl>
<b>Example</b> <div class="fragment"><pre class="fragment">  <span class="comment">// listen on a non-standard port for HTTP</span>
  <a class="code" href="group__webserver.html#g8d09559930507b44a8b6ba6888bcd8e0" title="Set the port that the webserver should listen on for new connections.">WebServer_SetListenPort</a>(8080);
</pre></div> 
<p>Definition at line <a class="el" href="webserver_8c-source.html#l00189">189</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge44633b0de4b28f0883744654f965e6d"></a><!-- doxytag: member="webserver.c::WebServer_WriteBodyEnd" ref="ge44633b0de4b28f0883744654f965e6d" args="(void *socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_WriteBodyEnd           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>socket</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the end of the Body tag - and the final end of HTML tag. 
<p>
Should be preceded by writes to the socket with the content of the page - this is often the last thing done in a handler. See <a class="el" href="group__webserver.html#g617645f84a704ca27ed9650270ee2d26" title="Adds a route handler to the WebServer.">WebServer_Route()</a> for a more complete example. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>The socket to write to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>non-zero on success, zero on failure.</dd></dl>
<b>Example</b> <div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> MyRequestHandler( <span class="keywordtype">char</span>* requestType, <span class="keywordtype">char</span>* address, <span class="keywordtype">char</span>* requestBuffer, 
                      <span class="keywordtype">int</span> requestMaxSize, <span class="keywordtype">void</span>* socket, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">int</span> len )
  {
    <span class="comment">// ... other code actually doing interesting things ...</span>
    <a class="code" href="group__webserver.html#ge44633b0de4b28f0883744654f965e6d" title="Writes the end of the Body tag - and the final end of HTML tag.">WebServer_WriteBodyEnd</a>(socket); <span class="comment">// now we're all done</span>
    <span class="keywordflow">return</span> 1;
  }
</pre></div> 
<p>Definition at line <a class="el" href="webserver_8c-source.html#l00456">456</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g33a47f02bdd0f2d8fd662648c4c0cad4"></a><!-- doxytag: member="webserver.c::WebServer_WriteBodyStart" ref="g33a47f02bdd0f2d8fd662648c4c0cad4" args="(char *reloadAddress, void *socket, char *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_WriteBodyStart           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>reloadAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the start of the BODY tag. 
<p>
Should be preceded by a call to <a class="el" href="group__webserver.html#g161fe09ada669a6f0a27f3e0dd6a0b0d" title="Writes the HTML header.">WebServer_WriteHeader()</a>. Also writes a light grey background. You can optionally specify that you'd like the page to automatically refresh itself once a second by passing in the address to reload to <b>reloadAddress</b>. See <a class="el" href="group__webserver.html#g617645f84a704ca27ed9650270ee2d26" title="Adds a route handler to the WebServer.">WebServer_Route()</a> for a more complete example. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reloadAddress</em>&nbsp;</td><td>A string signaling the address of a 1 second reload request. If it is NULL, no reload is requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>The socket to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Helper buffer which the function can use. Should be at least 300 bytes. This is usually the buffer passed into your handler as <b>buffer</b>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Helper buffer length. Also usually passed into your handler as <b>len</b>. </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>more parameterization of the tag</dd></dl>
<b>Example</b> <div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> MyRequestHandler( <span class="keywordtype">char</span>* requestType, <span class="keywordtype">char</span>* address, <span class="keywordtype">char</span>* requestBuffer, 
                      <span class="keywordtype">int</span> requestMaxSize, <span class="keywordtype">void</span>* socket, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">int</span> len )
  {
    <span class="comment">// ... usually write out the OK response and the header first ...</span>
    <a class="code" href="group__webserver.html#g33a47f02bdd0f2d8fd662648c4c0cad4" title="Writes the start of the BODY tag.">WebServer_WriteBodyStart</a>(0, socket, buffer, len); <span class="comment">// write the body start, with no reload</span>
    <span class="comment">// ... continue processing ...</span>
  }
</pre></div> 
<p>Definition at line <a class="el" href="webserver_8c-source.html#l00418">418</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g161fe09ada669a6f0a27f3e0dd6a0b0d"></a><!-- doxytag: member="webserver.c::WebServer_WriteHeader" ref="g161fe09ada669a6f0a27f3e0dd6a0b0d" args="(int includeCSS, void *socket, char *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_WriteHeader           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>includeCSS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the HTML header. 
<p>
Should be preceded by a call to <a class="el" href="group__webserver.html#ge56f4878fa8d9edea8144a125e331878" title="Writes the HTTP OK message and sets the content type to HTML.">WebServer_WriteResponseOkHTML()</a>. See <a class="el" href="group__webserver.html#g617645f84a704ca27ed9650270ee2d26" title="Adds a route handler to the WebServer.">WebServer_Route()</a> for a more complete example. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>includeCSS</em>&nbsp;</td><td>A flag signalling the inclusion of a very simple CSS header refining h1 and body text slightly. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>The socket to write to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Helper buffer which the function can use. Should be at least 300 bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Helper buffer length </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>non-zero on success, zero on failure. </dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>more parameterization</dd></dl>
<b>Example</b> <div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> MyRequestHandler( <span class="keywordtype">char</span>* requestType, <span class="keywordtype">char</span>* address, <span class="keywordtype">char</span>* requestBuffer, 
                      <span class="keywordtype">int</span> requestMaxSize, <span class="keywordtype">void</span>* socket, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">int</span> len )
  {
    <span class="comment">// ... usually write out the OK response first ...</span>
    <a class="code" href="group__webserver.html#g161fe09ada669a6f0a27f3e0dd6a0b0d" title="Writes the HTML header.">WebServer_WriteHeader</a>(<span class="keyword">true</span>, socket, buffer, len); <span class="comment">// write the header, including simple CSS</span>
    <span class="comment">// ... continue processing ...</span>
  }
</pre></div> 
<p>Definition at line <a class="el" href="webserver_8c-source.html#l00377">377</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge56f4878fa8d9edea8144a125e331878"></a><!-- doxytag: member="webserver.c::WebServer_WriteResponseOkHTML" ref="ge56f4878fa8d9edea8144a125e331878" args="(void *socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_WriteResponseOkHTML           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>socket</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the HTTP OK message and sets the content type to HTML. 
<p>
This will typically be the first thing you write out in your handler. Also see <a class="el" href="group__webserver.html#gf2e44af2fb70c641c47fc8954fd09067" title="Writes the HTTP OK message and sets the content type to plain text.">WebServer_WriteResponseOkPlain()</a> to set your response type to plain text. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>The socket to write to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>non-zero on success, zero on failure.</dd></dl>
<b>Example</b> <div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> MyRequestHandler( <span class="keywordtype">char</span>* requestType, <span class="keywordtype">char</span>* address, <span class="keywordtype">char</span>* requestBuffer, 
                      <span class="keywordtype">int</span> requestMaxSize, <span class="keywordtype">void</span>* socket, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">int</span> len )
  {
    <a class="code" href="group__webserver.html#ge56f4878fa8d9edea8144a125e331878" title="Writes the HTTP OK message and sets the content type to HTML.">WebServer_WriteResponseOkHTML</a>(socket); <span class="comment">// write the response out first</span>
    <span class="comment">// ... continue processing ...</span>
  }
</pre></div> 
<p>Definition at line <a class="el" href="webserver_8c-source.html#l00312">312</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gf2e44af2fb70c641c47fc8954fd09067"></a><!-- doxytag: member="webserver.c::WebServer_WriteResponseOkPlain" ref="gf2e44af2fb70c641c47fc8954fd09067" args="(void *socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WebServer_WriteResponseOkPlain           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>socket</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the HTTP OK message and sets the content type to plain text. 
<p>
This will typically be the first thing you write out in your handler. Also see <a class="el" href="group__webserver.html#ge56f4878fa8d9edea8144a125e331878" title="Writes the HTTP OK message and sets the content type to HTML.">WebServer_WriteResponseOkHTML()</a> to set your response type to HTML. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>The socket to write to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>non-zero on success, zero on failure.</dd></dl>
<b>Example</b> <div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> MyRequestHandler( <span class="keywordtype">char</span>* requestType, <span class="keywordtype">char</span>* address, <span class="keywordtype">char</span>* requestBuffer, 
                      <span class="keywordtype">int</span> requestMaxSize, <span class="keywordtype">void</span>* socket, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">int</span> len )
  {
    <a class="code" href="group__webserver.html#gf2e44af2fb70c641c47fc8954fd09067" title="Writes the HTTP OK message and sets the content type to plain text.">WebServer_WriteResponseOkPlain</a>(socket); <span class="comment">// write the response out first</span>
    <span class="comment">// ... continue processing ...</span>
  }
</pre></div> 
<p>Definition at line <a class="el" href="webserver_8c-source.html#l00349">349</a> of file <a class="el" href="webserver_8c-source.html">webserver.c</a>.</p>

</div>
</div><p>
</div>

<hr size="1">
<div>
  <p id="footer">The Make Controller Kit is an open source project maintained by <a href="http://www.makingthings.com">MakingThings</a>.<br />
    MakingThings code is released under the <a href="http://www.apache.org/licenses/LICENSE-2.0.html" target="_blank">Apache 2.0 license</a>.<br />
    Bug tracker, development wiki and status can be found at <a href="http://dev.makingthings.com">http://dev.makingthings.com</a>.<br />
    This document was last updated on 18 May 2009.
  </p>
</div>
<!-- Google Analytics Code -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
_uacct = "UA-769030-1";
urchinTracker();
</script>
</body>
</html>
